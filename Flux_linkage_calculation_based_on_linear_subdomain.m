function flux_linkage = Flux_linkage_calculation_based_on_linear_subdomain(parameters_of_rotor, parameters_of_stator, parameters_of_other_part, parameters_of_space_harmonics, parameters_of_time_harmonics)
% This function is used to calculate the flux-linkage generated by PM based
% on the linear subdomain model
import Winding_Matrix_Package.*;

%% Generate the time harmonics and space harmonics collection and determine the unit slot
% time harmonics collection
parameters_of_time_harmonics.time_harmonics_collection = union(parameters_of_time_harmonics.PM_time_harmonics, parameters_of_time_harmonics.current_time_harmonics);
parameters_of_time_harmonics.time_harmonics_collection = parameters_of_time_harmonics.time_harmonics_collection(:)'; % 强制使得时间谐波的合集为行向量
% space harmonics collection                                  
parameters_of_space_harmonics.PM_space_harmonics = PM_space_harmonics(parameters_of_stator, parameters_of_space_harmonics, parameters_of_time_harmonics);
parameters_of_space_harmonics.current_space_harmonics = Current_space_harmonics(parameters_of_stator, parameters_of_other_part, parameters_of_space_harmonics, parameters_of_time_harmonics);
parameters_of_space_harmonics.space_harmonics_collection = union(parameters_of_space_harmonics.PM_space_harmonics, parameters_of_space_harmonics.current_space_harmonics);
parameters_of_space_harmonics.space_harmonics_collection = parameters_of_space_harmonics.space_harmonics_collection(:)'; % 强制使得空间谐波的合集为行向量
% determine the unit slots 
parameters_of_stator.unit_slots = Unitslots(parameters_of_stator, parameters_of_other_part, parameters_of_time_harmonics);

%% Calculate the Winding matrix
parameters_of_windings.number_of_slots = parameters_of_stator.number_of_slot;
parameters_of_windings.pole_pairs_of_stator = parameters_of_stator.pole_pairs_of_stator;
parameters_of_windings.number_of_phase = parameters_of_stator.number_of_phase;
parameters_of_windings.turns_of_phase = parameters_of_stator.turns_of_phase;
parameters_of_windings.pitch_of_coils =  round(parameters_of_windings.number_of_slots/(2*parameters_of_windings.pole_pairs_of_stator));
unit_windingmatrix_of_phaseA= Unit_WindingMatrix_of_PhaseA(parameters_of_windings);
[~, integrated_winding_matrix] = Integrated_WindingMatrix(parameters_of_windings, unit_windingmatrix_of_phaseA);

%% Calculate the Az in the sloted motor
% initialize the parameters
time_harmonics_vertor = parameters_of_time_harmonics.time_harmonics_collection;
space_harmonics_vector = parameters_of_space_harmonics.space_harmonics_collection;
size_of_time_harmonics_vector = length(time_harmonics_vertor);
size_of_space_harmonics_vector = length(space_harmonics_vector);
size_of_space_harmonics = 4*size_of_space_harmonics_vector+...
    2*parameters_of_stator.unit_slots*(parameters_of_space_harmonics.lamda_max+1);
matrixCNmn = zeros(size_of_time_harmonics_vector, size_of_space_harmonics);

% calculate the Constant matrix 
m = 0;
for time_harmonics = time_harmonics_vertor
    m = m+1;
    matrixPNmn = MatrixPNmn_subdomain_time_harmonics(parameters_of_stator, parameters_of_rotor, parameters_of_other_part, parameters_of_space_harmonics, time_harmonics);
    matrixRNmn =  MatrixRNmn_subdomain_time_harmonics(parameters_of_stator, parameters_of_rotor, parameters_of_other_part, parameters_of_space_harmonics, parameters_of_time_harmonics, time_harmonics, integrated_winding_matrix);
    matrixCNmn_single_ref = linsolve(matrixPNmn, matrixRNmn);
    matrixCNmn_single = MatrixCNmn_reference_translation(parameters_of_stator, parameters_of_other_part, parameters_of_space_harmonics, matrixCNmn_single_ref);
    matrixCNmn(size_of_time_harmonics_vector+m, :) =  matrixCNmn_single';
    matrixCNmn(size_of_time_harmonics_vector-m+1, :) = MatrixCNmn_negative_time_harmonics(parameters_of_space_harmonics, matrixCNmn_single);
end

% calculate the flux-linkage of the windings
Omega_mechanical = 600; % (rpm)
omegam = 2*pi*Omega_mechanical/60; % (rad/s)
time_min = 0;
dtime =2*pi/omegam/parameters_of_rotor.pole_pairs_of_rotor/36;
time_max = 2*pi/omegam/parameters_of_rotor.pole_pairs_of_rotor-dtime;
size_of_time = round((time_max-time_min)/dtime+1);
flux_linkage_of_phase = zeros(parameters_of_stator.number_of_phase, size_of_time);

for time = time_min: dtime: time_max
    t = round((time-time_min)/dtime+1);
    thetam = omegam*time;
    matrixAz = MatrixAz_in_the_slots_subdomain_time_harmonics(parameters_of_stator, parameters_of_rotor, parameters_of_other_part, parameters_of_space_harmonics, parameters_of_time_harmonics, integrated_winding_matrix, matrixCNmn, thetam);
    flux_linkage_of_phase(:, t)= FluxLinkage_basedonAz(parameters_of_stator, parameters_of_other_part, matrixAz, integrated_winding_matrix);
end

%% Compute the fundamental harmonics of the flux-linkage
[~, Phi] = FFT(flux_linkage_of_phase(1, :), size_of_time);
phim = Phi(2);
flux_linkage = phim*parameters_of_stator.number_of_phase*0.5;

end

